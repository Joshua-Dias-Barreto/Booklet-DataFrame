!! DataFrame by example

In this chapter, I will guide you through the complete functionality of the DataFrame project by showing examples of how each of those features can be used. This is a documentation of DataFrame written in a form of storytelling with data.

!!! Weather dataset

For the demonstrational purposes, I have designed a simple dataset of meteorological observations. Imagine that in order to study the weather in certain area, you are collecting data by measuring the temperature and logging the type of precipitation (rain, snow etc.) every 20 minutes. The initial table contains only 5 observations (rows) and 3 features (columns): ''temperature'', ''precipitation'', and ''type''. You can see this table in the top left of Figure *@weatherDataFrame*.

Notice the following properties of this dataset that make it interesting for our study:
-It is small enough to be demonstrated on the pages of this booklet
-Each of its three columns has a different data type: ==Float==, ==Boolean==, ==String==

+Top left - data frame, top right - first column as data series, bottom - third row as data series. Data frame has 5 rows and 3 columns. Top row of the table represents column names of data frame, and the yellow column contains its row names. >Images/weather.png|width=90|label=weatherDataFrame+

!!! What are data frames and data series

Data frame is a table of data. Similar to Excel spreadsheet or a relational database, but implemented as a collection that can be stored in a variable, such as Array or Dictionary.

It is common to think of rows as observations and columns as features. Therefore, columns are usually homogeneous - they contain values of a same data type, and rows can be heterogeneous - contain values of different types, such as ==Integer==, ==Float==, ==Boolean==, ==String==, etc.

In the top left of Figure *@weatherDataFrame*, you can see the weather dataset, introduced in previous section, represented as a data frame. It contains three columns: ==Float== column of temperatures, ==Boolean== column which tells you whether or not there were any precipitations, and a ==String== column that specifies the type of precipitation. In Figure *@weatherDataFrame*, those data types are represented with the colors.

Each row or column can be extracted as a ==DataSeries== object - a dictionary of key-value pairs with a name. 

It is basically just an ordered dictionary with a name and an advanced API for data analysis. You can add two series together, multiply them by a number, calculate the variance or standard deviation of a series, select elements that satisfy a certain condition, and do many other things that will be described in this section.

You can see the example of two data series in Figure *@weatherDataFrame*. If you extract first column from the weather data frame (accessing rows and columns will be discussed in the next section), you will get a data series as in Figure *@weatherDataFrame* (B). It has a name which corresponds to a column name in data frame and lets us know where this series came from and what is the meaning of its values. The keys of the data series of a column are the row names. Similarly, if you ask the weather data frame for its third row, it will give you a data series as in Figure *@weatherDataFrame* (C). It also has a name which corresponds to a row name and keys which are the same a column names of the data frame.

As a result, although ==DataSeries== acts as an array of values, it is much more interpretable. By extracting a ==temperature== column, we get more than just array of 5 numbers. We also know that these numbers are temperatures and get the time (row name) at which each temperature was measured. In a same way, the row of measurements taken at ==01:50== remembers this time and associates each value to the name of that measurement (column name): ==temperature==, ==precipitation==, and ==type==.

Colors in Figure *@weatherDataFrame* represent data types. Although it is not a restriction of ==DataFrame==, it is common that columns are homogeneous - contain values of the same type, such as real values of temperatures or boolean values denoting whether or not there were any precipitation, while rows can be heterogeneous - contain values of different data types. In our example, the series of a row contains a real numerical value of temperature, a boolean value of precipitation, and a string value of precipitation type.

First, you need to install DataFrame v2.0 and make sure that it is passing all the tests.

!!! Installation

In order to install DataFrame, go to the Playground (Ctrl\+O\+W) in your fresh Pharo image and execute the following Metacello script (select it and press Do-it button or Ctrl\+D):

[[[language=smalltalk
Metacello new
  baseline: 'DataFrame';
  repository: 'github://PolyMathOrg/DataFrame/src';
  load.
]]]

In all keyboard shortcuts mentioned in this booklet the ''Ctrl'' key is for Windows and Linux. On Mac OS, use ''Cmd'' instead.

!!! Running the tests

First thing you should do after installing DataFrame is open the DataFrame-Tests package in Test Runner (Ctrl\+O\+U) or System Browser (Ctrl\+O\+B) and make sure that all tests are passing. DataFrame v2.0 is tested with 301 unit tests which provide 90\% code coverage. If you see some failing tests, please go to the DataFrame repository on GitHub and open an issue describing your problem.

!!! Creating a data series

==DataSeries== behaves like an ==OrderedDictionary==. You can create it by providing keys, values, and a name:

[[[
DataSeries
  withKeys: (#('01:10' '01:30' '01:50' '02:10' '02:30') collect: #asTime)
  values: #(2.4 0.5 -1.2 -2.3 3.2)
  name: #temperature.
]]]

This creates the first column of our weather data frame.

| |!temperature
|!1:10 am |2.4
|!1:30 am |0.5
|!1:50 am |-1.2
|!2:10 am |-2.3
|!2:30 am |3.2

If you don't specify a name, it will be set to the default value =='(no name)'==:

[[[
DataSeries
  withKeys: #(temperature precipitation type)
  values: #(0.5 true rain).
]]]

| |!(no name)
|!temperature |0.5
|!precipitation |true
|!type |rain

You can also create a data series without keys, in which case they fill be filled with default values: numbers from 1 to the size of your data series:

[[[
DataSeries
  withValues: #(2.4 0.5 -1.2 -2.3 3.2)
  name: #temperature.
]]]

| |!temperature
|!1 |2.4
|!2 |0.5
|!3 |-1.2
|!4 |-2.3
|!5 |3.2

Or only with values:

[[[
DataSeries
  withValues: #(2.4 0.5 -1.2 -2.3 3.2).
]]]

| |!(no name)
|!1 |2.4
|!2 |0.5
|!3 |-1.2
|!4 |-2.3
|!5 |3.2

That last expression has a shorter form which produces the same result:

[[[
#(2.4 0.5 -1.2 -2.3 3.2) asDataSeries.
]]]

!!! Few more words about data series

!!! Creating a data frame

In this section I will describe different ways of creating a new data frame. First I will show how to create data frame from Figure *@weatherDataFrame* and how to initialize an empty data frame.

!!!! Initializing a data frame with an array of rows

The most basic way to initialize a data frame is with an array (or any other ordered collection) of rows where each row is a collection of elements.

[[[
weather := DataFrame withRows: #(
  (2.4 true rain)
	(0.5 true rain)
  (-1.2 true snow)
  (-2.3 false -)
	(3.2 true rain)).
]]]

!!!! Initializing a data frame with an array of columns

Alternatively, you can create a data frame by passing it a collection of columns. This can be handy, for example, when we engineer new features: ==DataFrame withColumns: { income . income ** 2 . income log }==. In our case, we create the same weather dataset:

[[[
weather := DataFrame withColumns: #(
  (2.4 0.5 -1.2 -2.3 3.2)
  (true true true false true)
  (rain rain snow - rain)).
]]]

!!!! Specifying column and row names

Both expressions in the previous sections produce the same data frame.

| |!1 |!2 |!3
|!1 |2.4 |true |rain
|!2 |0.5 |true |rain
|!3 |-1.2 |true |snow
|!4 |-2.3 |false |-
|!5 |3.2 |true |rain

Since the names of rows and columns were not specified, they were initialized with their default values: ==(1 to: self numberOfRows)== and ==(1 to: self numberOfColumns)==. We can provide more meaningful names:

[[[
weather columnNames: #(temperature precipitation type).
weather rowNames: (#('01:10' '01:30' '01:50' '02:10' '02:30')
		collect: #asTime).
]]]

Notice that the names don't have to be strings or numbers. They can be any objects, and in this case there are instances of Time. Now the data frame looks the same as the one in Figure *@weatherDataFrame* (A).

| |!temperature |!precipitation |!type
|!1:10 am |2.4 |true |rain
|!1:30 am |0.5 |true |rain
|!1:50 am |-1.2 |true |snow
|!2:10 am |-2.3 |false |-
|!2:30 am |3.2 |true |rain

!!!! Compact methods for initializing data frames

==DataFrame== provides some syntactic sugar that allows us to initialize it with contents and (optionally) row and column names in a single line. Here is the complete list of those initializers:

[[[
DataFrame class >> withRows: columnNames:
DataFrame class >> withRows: rowNames:
DataFrame class >> withRows: rowNames: columnNames:
DataFrame class >> withColumns: columnNames:
DataFrame class >> withColumns: rowNames:
DataFrame class >> withColumns: rowNames: columnNames:
]]]

Whenever row or column names are not specified, they are initialized with their default values.

!!!! Creating empty data frames

Sometimes we need to create an empty data frame that will be filled with data later on. The easiest way of doing this is with

[[[
DataFrame new. "empty data frame with 0 rows and 0 columns"
]]]

This will create an empty data frame with 0 columns and 0 rows. You can also create an empty data frame of a given size (specified as a point ==numberOfRows @ numberOfColumns==). All cells of such data frame will be empty (initialized with ==nil==).

[[[
DataFrame new: 3@4. "empty data frame with 3 rows and 4 columns"
]]]

Similarly to the syntactic sugar described in the previous section, DataFrame class has methods that allow us to create data frames by specifying only their rows, columns, or both. Since we do not provide any data, such data frames with be empty and their sizes will correspond to the provided arrays of rows and columns. For example, if you create an empty data frame with columns ==#(temperature precipitation type)==, its size will be ==0@3==. Here are the methods that can be used to create an empty data frame with names:

[[[
DataFrame class >> withColumnNames:
DataFrame class >> withRowNames:
DataFrame class >> withRowNames: columnNames:
]]]

For example, we can initialize an empty weather data frame:

[[[
emptyWeather := DataFrame
  withRowNames: (#('01:10' '01:30' '01:50' '02:10' '02:30') collect: #asTime)
  columnNames: #(temperature precipitation type).
]]]

| |!temperature |!precipitation |!type
|!1:10 am |nil |nil |nil
|!1:30 am |nil |nil |nil
|!1:50 am |nil |nil |nil
|!2:10 am |nil |nil |nil
|!2:30 am |nil |nil |nil

@@note Although it is possible to create an empty data frame using ==DataFrame class >> new== and add rows later by pushing them one by one, this is not recommended. DataFrame is not optimized for insertion of new elements. It may be more efficient to first add rows into an OrderedCollection and then initialize a DataFrame with it.

!!! Inspecting a data frame

+Top left - data frame, top right - first column as data series, bottom - third row as data series. Data frame has 5 rows and 3 columns. Top row of the table represents column names of data frame, and the yellow column contains its row names. >Images/fastTableWhite.png|width=100|label=fastTable+

!!! Accessing parameters of data frame

Data frames are defined by their contents (table of data), as well as their column and row names. For the simplicity we provide access to some additional parameters such as the dimensions of a data frame. In the following sections, we will discuss how to access row and columns, as well as its individual cells. In this section, I will show you how to get other parameters such as names or sizes.

!!!! Dimensions

Getting the number of rows and columns of a data frame is straightforward:

[[[
weather numberOfRows. "5"
weather numberOfColumns. "3"
]]]

You can also get both dimensions of a data frame as a ==Point==:

[[[
weather dimensions. "5@3"
]]]

!!!! Row and column names

Every data frame has names associated to its rows and columns. These names can be used for referencing specific rows or columns (which we will see in the following sections). To get the collection of names for

[[[
weather rowNames.
weather columnNames.
]]]

!!!! Transposed DataFrame

Sometimes it is useful to transpose a data frame made out of columns and rows into rows and columns. To do that, you can simply write

[[[
weather transposed
]]]

The result will be a new data frame which looks like this:

| |!1:10 am |!1:30 am |!1:50 am |!2:10 am |!2:30 am
|!temperature |2.4 |0.5 |-1.2 |-2.3 |3.2
|!precipitation |true |true |true |false |true
|!type |rain |rain |snow |- |rain

!!! Accessing rows and columns

Rows and columns of a data frame can be accessed either by their names or their numeric indexes.

!!!! Accessing by name

You can get row ==01:50== and the column ==temperature== of the weather data frame by writing:

[[[
weather row: '01:50' asTime.
weather column: #temperature.
]]]

You can also modify the values stores in that row or column:

[[[
weather row: '01:50' asTime put: #(10 true rain).
weather column: #temperature put: #(1.2 -2.1 3.4 -5.9 -0.4).
]]]

| |!temperature |!precipitation |!type
|!1:10 am |1.2 |true |rain
|!1:30 am |-2.1 |true |rain
|!1:50 am |3.4 |true |rain
|!2:10 am |-5.9 |false |-
|!2:30 am |-0.4 |true |rain

If you reference a row or column by a non-existing name you will get the ==NotFoundError== and if the array you provide is too big or too small, you will get the ==SizeMismatch== error. Notice that you can not add a new column using ==dataFrame column: #newName put newArray==. This is done with ==addColumn:== set of methods that will be described in the following sections.

!!!! Accessing by index

Alternatively, rows and columns can be accessed using their numeric indices. You can get the same row and column as in the previous example using

[[[
weather rowAt: 3.
weather columnAt: 1.
]]]

Similarly, you can modify them using ==rowAt: put:== and ==columnAt: put:==. Let's undo the changes that we made in the previous section:

[[[
weather rowAt: 3 put: #(-1.2 true snow).
weather columnAt: 1 put: #(2.4 0.5 -1.2 -2.3 3.2).
]]]

| |!temperature |!precipitation |!type
|!1:10 am |2.4 |true |rain
|!1:30 am |0.5 |true |rain
|!1:50 am |-1.2 |true |snow
|!2:10 am |-2.3 |false |-
|!2:30 am |3.2 |true |rain

!!!! Accessing multiple rows and columns

You can access multiple columns at a same time by providing an array of column names or indices, or by specifying the range of indices. Here is an example of how you can get the three rows in the middle of weather data frame:

[[[
weather rows: { '01:30' asTime . '01:50' asTime . '02:10' asTime}.
weather rowsAt: #(2 3 4).
weather rowsFrom: 2 to: 4.
]]]

The same can be done to access, for example, last two columns of our data frame:

[[[
weather columns: #(precipitation type).
weather columnsAt: #(2 3).
weather columnsFrom: 2 to: 3.
]]]

The result will be another data frame with only the requested rows or columns in the order in which you ask for them. This means that you can ask for rows 3, 2, and the 5 or column ==precipitation== followed by the ==temperature==:

[[[
weather rowsAt: #(3 2 5).
weather columns: #(precipitation temperature).
]]]

All the above methods can be used together with ==put:== to replace the given rows or columns with new ones:

[[[
DataFrame >> rows: put:
DataFrame >> rowsAt: put:
DataFrame >> rowsFrom: to: put:
DataFrame >> columns: put:
DataFrame >> columnsAt: put:
DataFrame >> columnsFrom: to: put:
]]]

!!!! Head and Tail

To understand the nature of a dataset with 100,000 rows, it helps if we can take a look at its first or last 5 rows. This is called the ""head"" or ""tail"" of a dataset. ==DataFrame== allows you to get the arbitrary number of rows at its beginning or end using ==head: aNumber== and ==tail: aNumber== methods. It also provides simpler methods ==head== and ==tail== which return 5 rows by default.

For example, if we want to get the first 2 rows from our weather data frame:

[[[
weather head: 2.
]]]

| |!temperature |!precipitation |!type
|!1:10 am |2.4 |true |rain
|!1:30 am |0.5 |true |rain

Or the tail with the last 3 rows:

[[[
weather tail: 2.
]]]

| |!temperature |!precipitation |!type
|!1:50 am |-1.2 |true |snow
|!2:10 am |-2.3 |false |-
|!2:30 am |3.2 |true |rain

Both ==head== and ==tail== are returned to you as new data frames with only the corresponding rows. DataSeries also implements the ==head==/==tail== methods, which allows you to get the ==head== or ==tail== of a single row or column as a new data series with only the first or last elements

[[[
(weather column: #temperature) head: 2.
]]]

| |!temperature
|!1:10 am |2.4
|!1:30 am |0.5

!!! Adding rows and columns
@secAddingRowsAndColumns

You can add new rows and columns to data frame by providing an array of values a name of the new row or column, and its position as an index:

[[[
weather
  addColumn: #(86 79 23 16 90)
  named: #humidity
  atPosition: 2.
]]]

The above statement will modify the weather dataset by adding a humidity column to it right after the temperature column:

| |!temperature |!humidity |!precipitation |!type
|!1:10 am |2.4 |86 |true |rain
|!1:30 am |0.5 |79 |true |rain
|!1:50 am |-1.2 |23 |true |snow
|!2:10 am |-2.3 |16 |false |-
|!2:30 am |3.2 |90 |true |rain

You can omit the position using methods ==addRow:named:== or ==addColumn:named:==. By default rows and columns will be added to the end of data frame:

[[[
weather
  addRow: #(2.0 81 true rain)
  named: '2:50' asTime.
]]]

| |!temperature |!humidity |!precipitation |!type
|!1:10 am |2.4 |86 |true |rain
|!1:30 am |0.5 |79 |true |rain
|!1:50 am |-1.2 |23 |true |snow
|!2:10 am |-2.3 |16 |false |-
|!2:30 am |3.2 |90 |true |rain
|!2:50 am |2.0 |81 |true |rain

Alternatively, you can add new rows or columns as data series. In this case you do not need to provide a name because the data series already knows its name.

[[[
wind := DataSeries
  withValues: #(39 39 32 24 14 14)
  name: #wind.

weather
  addColumn: wind
  atPosition: 2.
]]]

Notice that we did not specify the keys of the data series with wind measurements. It was initialized with default keys. When adding new row or column as a data series, ==DataFrame== does not take keys into account.

| |!temperature |!wind |!humidity |!precipitation |!type
|!1:10 am |2.4 |39 |86 |true |rain
|!1:30 am |0.5 |39 |79 |true |rain
|!1:50 am |-1.2 |32 |23 |true |snow
|!2:10 am |-2.3 |24 |16 |false |-
|!2:30 am |3.2 |14 |90 |true |rain
|!2:50 am |2.0 |14 |81 |true |rain

You can use ==addRow:== or ==addColumn:== without specifying the position, in which case the new row or column will be added to the end.

Just as before, when we were modifying the existing rows and columns, if you try to add new row or column which is too big or too small, ==DataFrame== will signal a ==SizeMismatch== error.

!!! Removing rows and columns

To remove a row or column from a data frame, you have to provide either its name or index. In the previous section we have added two columns and one row to the data frame. Now we can remove the ==wind== column and the last row that was added:

[[[
weather removeColumn: #wind.
weather removeRowAt: 6.
]]]

This gives us the same weather dataset as we had at the beginning with an additional ==humidity== column.

| |!temperature |!humidity |!precipitation |!type
|!1:10 am |2.4 |86 |true |rain
|!1:30 am |0.5 |79 |true |rain
|!1:50 am |-1.2 |23 |true |snow
|!2:10 am |-2.3 |16 |false |-
|!2:30 am |3.2 |90 |true |rain

If you try to remove a column or row by a name which does not exist or by index that is out of range, you will get the ==NotFoundError== or ==SubscriptOutOfBounds==.

!!! Enumerating rows of data frame

==DataFrame== can be treated as an array of rows. You can enumerate them in the same way as you enumerate any other sequenceable collection in Smalltalk: ==do:==, ==collect:==, ==select:==, ==reject:==, and ==inject:into:==.

!!!! do: aBlock

Evaluate ==aBlock== for each row of the receiver data frame. Let us convert the temperatures from Celsius to Fahrenheit:

[[[
weather do: [ :row |
  row at: #temperature transform: [ :celsius |
    celsius * 9/5 + 32 ] ].
]]]

| |!temperature |!humidity |!precipitation |!type
|!1:10 am |36.32 |86 |true |rain
|!1:30 am |32.9 |79 |true |rain
|!1:50 am |29.84 |23 |true |snow
|!2:10 am |27.86 |16 |false |-
|!2:30 am |37.76 |90 |true |rain

!!!! select: aBlock

Evaluate ==aBlock== for each row of the receiver data frame. Collect into a new data frame only those rows for which ==aBlock== evaluates to ==true==. Answer the new data frame. We can select the records that are below the freezing temperature:

[[[
weather select: [ :row |
  (row at: #temperature) < 32 ].
]]]

| |!temperature |!humidity |!precipitation |!type
|!1:50 am |29.84 |23 |true |snow
|!2:10 am |27.86 |16 |false |-

!!!! reject: aBlock

Evaluate ==aBlock== for each row of the receiver data frame. Collect into a new data frame only those rows for which ==aBlock== evaluates to ==false==. Answer the new data frame. Now if we reject the freezing temperatures, we will get all other records.

[[[
weather reject: [ :row |
  (row at: #temperature) < 32 ].
]]]

| |!temperature |!humidity |!precipitation |!type
|!1:10 am |36.32 |86 |true |rain
|!1:30 am |32.9 |79 |true |rain
|!2:30 am |37.76 |90 |true |rain

!!!! collect: aBlock

Evaluate ==aBlock== for each row of the receiver data frame. Collect into a new data frame the rows that were answered by ==aBlock==. Therefore, ==aBlock== is expected to return a data series of certain size. This size can be different than the number of columns in the original data frame, but the same for every answered row. Keys of the answered data series will be set as column names of the new data frame. For example, we can collect rows of weather data frame into a new data frame with the values of ==humidity== column converted to the 0-1 scale and with ==precipitation== column removed:

[[[
weather collect: [ :row |
  row at: #humidity transform: [ :percent | percent / 100 ].
  row removeAt: #precipitation.
  row ].
]]]

The result will be a new data frame:

| |!temperature |!humidity |!type
|!1:10 am |36.32 |0.86 |rain
|!1:30 am |32.9 |0.79 |rain
|!1:50 am |29.84 |0.23 |snow
|!2:10 am |27.86 |0.16 |-
|!2:30 am |37.76 |0.9 |rain

Remember that the original weather data frame is not modified.

!!!! detect: aBlock

Evaluate ==aBlock== for each row of the receiver data frame. Answer the first row for which ==aBlock== evaluates to ==true==. If none evaluates to ==true==, report an error. For example, we can detect the first row with a freezing temperature:

[[[
weather detect: [ :row |
  (row at: #temperature) < 32 ].
]]]

| |!1:50 am
|!temperature |29.84
|!humidity |23
|!precipitation |true
|!type |snow

!!!! detect: aBlock ifNone: exceptionBlock

Evaluate ==aBlock== for each row of the receiver data frame. Answer the first row for which ==aBlock== evaluates to ==true==. If none evaluates to ==true==, evaluate ==exceptionBlock== which must be a block requiring no arguments. For example, since weather dataset does not contain any observations (rows) with temperatures lower than 20, the following expression will evaluate to the ''not found'' string:

[[[
weather
  detect: [ :row | (row at: #temperature) < 20 ]
  ifNone: [ 'not found' ].
]]]

!!!! inject: thisValue into: binaryBlock

Evaluate ==binaryBlock== once for each row in the receiver data frame. The block has two arguments: the second one is the row from the receiver; the first one is the is the value of the previous evaluation of the block, starting the argument ==thisValue==. Answer the final value of a block.

We can use it to sum up all values of the two numeric columns: ==temperature== and ==humidity==:

[[[
(weather columns: #(temperature humidity))
	inject: 0
	into: [ :sum :row | sum + row ].
]]]

| |!(no name)
|!temperature |164.68
|!humidity |294

Additionaly, ==DataFrame== provides special methods for enumerating it with row index.

We do not need to enumerate rows with their names.

!!! Aggregation and Grouping

Aggregation and grouping is among the most used operations in data analysis workflow. It allows us to first group rows of a data frame by a value of some column and then aggregate each one of these groups into a single value with some function or block, for example, ==average==, ==sum==, etc.

Let's ask weather data frame to answer the following question: ''"What is the average temperature when it rains, snows, or when there is no precipitation?"''. To do that, we group the values of ==temperature== column by the ==type== column and find the average value of each group.

[[[
weather
	group: #temperature
	by: #type
	aggregateUsing: #average
  as: #averageTemperature.
]]]

This gives us a data series of average temperatures by precipitation type called ==averageTemperature==:

| |!averageTemperature
|!- |27.86
|!rain |35.66
|!snow |29.84

You can omit the ==as: #averageTemperature== part of that message, in which case the answered data series will have the same name as the column that was aggregated: ==temperature==.

Values of data series are grouped into a data series of groups where each group is also a data series. Aggregation function or block is then applied to each one of these groups. Which means that aggregation function can be any selector understood by ==DataSeries==. And the result of aggregation and grouping expression will be a data series of answers from your aggregation function or block (which can be scalar values or collections).

Let's look at the total number of rows, lowest and highest temperature values, and average humidity in each group:

[[[
weather
  groupBy: #type
  aggregate: {
    #temperature using: #size as: #count .
    #temperature using: #min as: #minTemperature .
    #temperature using: #max as: #maxTemperature .
    #humidity using: #average as: #avgHumidity }.
]]]

Notice that ==count== column is constructed by aggregating groups of ==temperature== with ==#size== message. In fact, any column can be used in place of ==temperature==.

| |!count |!minTemperature |!maxTemperature |!avgHumidity
|!- |1 |27.86 |27.86 |16
|!rain |3 |32.9 |37.76 |85
|!snow |1 |29.84 |29.84 |23

!!! Reading from and writing to files

In practice, data frames are useful when you can load some data from an external source into a data frame, modify and analyse it, then save result. External source can be a CSV or Excel file, a database connection, or any other source of data In this section I will describe the ==DataFrame-IO== package of the ==DataFrame project== which allows you to load and save data frames.

==DataFrame-IO== provides two abstract classes: ==DataFrameReader== and ==DataFrameWriter==. Each of them has only one abstract method: ==DataFrameReader >> readFrom: aLocation== (expected to return a data frame) and ==DataFrameWriter >> write: aDataFrame to: aLocation==. In order to add support for some external data source, you need to override those methods in your subclasses, providing the actual algorithm for reading and writing data. ==DataFrame== has two methods that allow you to read or write it using your reader or writer:

[[[
DataFrame class >> readFrom: aLocation using: aDataFrameReader
  "Read data frame from a given location using a given DataFrameReader. Location can be a file reference, a database connection, or something else (depending on the implementation of the reader)"
  ^ aDataFrameReader readFrom: aLocation
]]]
[[[
DataFrame >> writeTo: aLocation using: aDataFrameWriter
  "Write data frame to a given location using a given DataFrameWriter. Location can be a file reference, a database connection, or something else (depending on the implementation of the writer)"
  aDataFrameWriter write: self to: aLocation
]]]

!!!! CSV support

""CSV"" (comma-separated values) is the file format that is most commonly used by data scientists to save and share tabular data. It is a simple text file in which each row is written on the new line and values of a row are separated by commas. You can use other character as separator instead of comma, for example, one common choice is tabulation.

==DataFrame-IO== package comes with two subclasses of ==DataFrameReader== and ==DataFrameWriter==: ==DataFrameCsvReader== and ==DataFrameCsvWriter==. They override ==readFrom:== and ==write:to:== methods using ==NeoCSV== ${footnote:note=https://github.com/svenvc/NeoCSV}$ and allow you to make optional configurations, such as specifying the separator character (comma by default) or line end convention (either ==#cr==, ==#lf==, or ==#crlf==, by default we choose the one used by your OS). By default, ==DataFrameCsvReader== will read all columns of the CSV file as data frame columns and assign the default names to rows - numbers from 1 to ==numberOfRows==. However, you can configure it to read first column as row names by sending ==true== to the ==DataFrameCsvReader >> includeRowNames:==. In this case ==aLocation== parameter of ==readFrom:== and ==write:to:== methods is expected to be a ==FileReference==.

!!! Conclusion

==DataFrame== is a powerful abstraction that manipulates and returns ==DataSeries== (named dictionaries).
